/**************************************************************************
 *	HyText2dData.cpp
 *	
 *	Harmony Engine
 *	Copyright (c) 2013 Jason Knobler
 *
 *	Harmony License:
 *	https://github.com/OvertureGames/HarmonyEngine/blob/master/LICENSE
 *************************************************************************/
#include "Afx/HyStdAfx.h"
#include "Assets/Nodes/HyText2dData.h"
#include "Renderer/IHyRenderer.h"
#include "Diagnostics/Console/IHyConsole.h"

HyText2dData::FontState::FontState(Typeface *pTypefaces, float fLineHeight, float fLineAcender, float fLineDescender, float fLeftSideNudgeAmt, HyJsonArray layersArray) :
	fLINE_HEIGHT(fLineHeight),
	fLINE_ASCENDER(fLineAcender),
	fLINE_DESCENDER(fLineDescender),
	fLEFT_SIDE_NUDGE_AMT(fLeftSideNudgeAmt),
	uiNUM_LAYERS(layersArray.Size())
{
	pLayers = reinterpret_cast<Layer *>(HY_NEW unsigned char[sizeof(Layer) * uiNUM_LAYERS]);
	Layer *pLayerWriteLocation = pLayers;

	for(uint32 i = 0; i < uiNUM_LAYERS; ++i, ++pLayerWriteLocation)
	{
		HyJsonObj layerObj = layersArray[i].GetObject();
		new (pLayerWriteLocation)Layer(layerObj["topR"].GetFloat(),
									   layerObj["topG"].GetFloat(),
									   layerObj["topB"].GetFloat(),
									   layerObj["botR"].GetFloat(),
									   layerObj["botG"].GetFloat(),
									   layerObj["botB"].GetFloat(),
									   pTypefaces[layerObj["typefaceIndex"].GetUint()]);
	}
}

HyText2dData::FontState::~FontState()
{
	unsigned char *pLayerBuffer = reinterpret_cast<unsigned char *>(pLayers);
	delete[] pLayerBuffer;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HyText2dData::HyText2dData(const std::string &sPath, HyJsonObj itemDataObj, HyAssets &assetsRef) :
	IHyNodeData(sPath),
	m_pTypefaces(nullptr),
	m_uiNumTypefaces(0),
	m_pFontStates(nullptr)
{
	HyRectangle<float> rSubAtlasUVRect;

#ifdef HY_PLATFORM_GUI
	if(sPath == HY_GUI_DATAOVERRIDE)
		m_pAtlas = nullptr;
	else
		m_pAtlas = assetsRef.GetAtlas(itemDataObj["checksum"].GetUint(), rSubAtlasUVRect);
#else
	m_pAtlas = assetsRef.GetAtlas(itemDataObj["checksum"].GetUint(), rSubAtlasUVRect);
#endif
	
	// NOTE: m_pAtlas may be nullptr if this is a preview generated by the Editor Tool
	//
	uint32 uiFullAtlasWidth, uiFullAtlasHeight;
	if(m_pAtlas)
	{
		m_RequiredAtlases.Set(m_pAtlas->GetManifestIndex());

		uiFullAtlasWidth = m_pAtlas->GetWidth();
		uiFullAtlasHeight = m_pAtlas->GetHeight();
	}
	else
	{
		rSubAtlasUVRect.left = rSubAtlasUVRect.top = 0.0f;
		rSubAtlasUVRect.right = rSubAtlasUVRect.bottom = 1.0f;

		if(itemDataObj.HasMember("subAtlasWidth") && itemDataObj.HasMember("subAtlasHeight"))
		{
			uiFullAtlasWidth = static_cast<uint32>(HyMax(0, itemDataObj["subAtlasWidth"].GetInt()));
			uiFullAtlasHeight = static_cast<uint32>(HyMax(0, itemDataObj["subAtlasHeight"].GetInt()));
		}
		else
		{
			uiFullAtlasWidth = 0;
			uiFullAtlasHeight = 0;
		}
	}
	
	float fSubAtlasWidth = uiFullAtlasWidth * (rSubAtlasUVRect.right - rSubAtlasUVRect.left);
	float fSubAtlasHeight = uiFullAtlasHeight * (rSubAtlasUVRect.bottom - rSubAtlasUVRect.top);
	
	HyJsonArray fontArray = itemDataObj["fontArray"].GetArray();
	m_uiNumTypefaces = fontArray.Size();
	
	m_pTypefaces = HY_NEW Typeface[m_uiNumTypefaces];
	for (uint32 i = 0; i < m_uiNumTypefaces; ++i)
	{
		Typeface &curTypeface = m_pTypefaces[i];

		HyJsonObj typefaceObj = fontArray[i].GetObject();
		HyJsonArray glyphsArray = typefaceObj["glyphs"].GetArray();
		
		uint32 uiNumGlyphs = glyphsArray.Size();
		for (uint32 j = 0; j < uiNumGlyphs; ++j)
		{
			HyJsonObj glyphObj = glyphsArray[j].GetObject();

			float fLeftUv = (uiFullAtlasWidth * rSubAtlasUVRect.left) + (fSubAtlasWidth * glyphObj["left"].GetFloat());
			fLeftUv /= uiFullAtlasWidth;
			float fTopUv = (uiFullAtlasHeight * rSubAtlasUVRect.top) + (fSubAtlasHeight * glyphObj["top"].GetFloat());
			fTopUv /= uiFullAtlasHeight;
			float fRightUv = (uiFullAtlasWidth * rSubAtlasUVRect.left) + (fSubAtlasWidth * glyphObj["right"].GetFloat());
			fRightUv /= uiFullAtlasWidth;
			float fBottomUv = (uiFullAtlasHeight * rSubAtlasUVRect.top) + (fSubAtlasHeight * glyphObj["bottom"].GetFloat());
			fBottomUv /= uiFullAtlasHeight;

			uint32 uiCode = glyphObj["code"].GetUint();
			HyAssert(curTypeface.find(uiCode) == curTypeface.end(), "Duplicate glyph codes found - fix in HyEditor");
			curTypeface[uiCode] = HY_NEW HyText2dGlyphInfo(
				glyphObj["width"].GetUint(),
				glyphObj["height"].GetUint(),
				glyphObj["offset_x"].GetInt(),
				glyphObj["offset_y"].GetInt(),
				glyphObj["advance_x"].GetFloat(),
				glyphObj["advance_y"].GetFloat(),
				fLeftUv,
				fTopUv,
				fRightUv,
				fBottomUv);
		}
	}

	HyJsonArray stateArray = itemDataObj["stateArray"].GetArray();
	m_uiNumStates = stateArray.Size();

	m_pFontStates = reinterpret_cast<FontState *>(HY_NEW unsigned char[sizeof(FontState) * m_uiNumStates]);
	FontState *pStateWriteLocation = m_pFontStates;
	for (uint32 i = 0; i < stateArray.Size(); ++i, ++pStateWriteLocation)
	{
		HyJsonObj stateObj = stateArray[i].GetObject();
		new (pStateWriteLocation)FontState(m_pTypefaces,
										   stateObj["lineHeight"].GetFloat(),
										   stateObj["lineAscender"].GetFloat(),
										   stateObj["lineDescender"].GetFloat(),
										   stateObj["leftSideNudgeAmt"].GetFloat(),
										   stateObj["layers"].GetArray());
	}
}

HyText2dData::~HyText2dData(void)
{
	for(uint32 i = 0; i < m_uiNumStates; ++i)
		m_pFontStates[i].~FontState();
	unsigned char *pFontStatesBuffer = reinterpret_cast<unsigned char *>(m_pFontStates);
	delete[] pFontStatesBuffer;

	for(uint32 i = 0; i < m_uiNumTypefaces; ++i)
	{
		for(auto iter = m_pTypefaces[i].begin(); iter != m_pTypefaces[i].end(); ++iter)
			delete iter->second;
	}
	delete[] m_pTypefaces;
}

uint32 HyText2dData::GetNumLayers(uint32 uiStateIndex) const
{
	return m_pFontStates[uiStateIndex].uiNUM_LAYERS;
}

const HyText2dGlyphInfo *HyText2dData::GetGlyph(uint32 uiStateIndex, uint32 uiLayerIndex, uint32 uiUtf32Code) const
{
	// Special case: No-Break Space CodePoint: 160
	if(uiUtf32Code == 160)
		uiUtf32Code = 32; // Use standard space (no breaks should occur because it should act as a regular character from this point)

	auto iter = m_pFontStates[uiStateIndex].pLayers[uiLayerIndex].TYPEFACE_REF.find(uiUtf32Code);
	if(iter == m_pFontStates[uiStateIndex].pLayers[uiLayerIndex].TYPEFACE_REF.end())
	{
		HyLogWarning("Missing glyph code " << uiUtf32Code << " in Text instance: " << GetPath());

		// Instead return Unicode Character 'REPLACEMENT CHARACTER' (U+FFFD) which should always be available
		iter = m_pFontStates[uiStateIndex].pLayers[uiLayerIndex].TYPEFACE_REF.find(65533);
		if(iter == m_pFontStates[uiStateIndex].pLayers[uiLayerIndex].TYPEFACE_REF.end())
		{
			HyError("Could not retrive Unicode Character 'REPLACEMENT CHARACTER' (U+FFFD) which should always be available");
			return nullptr; // Returning nullptr here causes glitched out sprites and other corruption. Fatal error.
		}
	}

	return iter->second;
}

HyColor HyText2dData::GetDefaultColor(uint32 uiStateIndex, uint32 uiLayerIndex, bool bTop) const
{
	if(bTop)
		return m_pFontStates[uiStateIndex].pLayers[uiLayerIndex].DEFAULT_TOP_COLOR;
	else
		return m_pFontStates[uiStateIndex].pLayers[uiLayerIndex].DEFAULT_BOT_COLOR;
}

HyFileAtlas *HyText2dData::GetAtlas() const
{
	return m_pAtlas;
}

float HyText2dData::GetLineHeight(uint32 uiStateIndex) const
{
	return m_pFontStates[uiStateIndex].fLINE_HEIGHT;
}

float HyText2dData::GetLineAscender(uint32 uiStateIndex) const
{
	return m_pFontStates[uiStateIndex].fLINE_ASCENDER;
}

float HyText2dData::GetLineDescender(uint32 uiStateIndex) const
{
	return m_pFontStates[uiStateIndex].fLINE_DESCENDER;
}

float HyText2dData::GetLeftSideNudgeAmt(uint32 uiStateIndex) const
{
	if(m_pFontStates)
		return m_pFontStates[uiStateIndex].fLEFT_SIDE_NUDGE_AMT;

	return 0.0f;
}
